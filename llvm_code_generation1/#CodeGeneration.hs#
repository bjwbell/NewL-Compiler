module CodeGeneration where
import TypeNames
genCode (Program mainClass classDeclList) classes =  
 if genCodeMainClass mainClass classes == "Ok" 
 then genCodeClassDeclList classDeclList classes
 else "Fail1" ++ " " ++ (genCodeMainClass mainClass classes)

genCodeClassDeclList CEmpty classes = "Ok"
genCodeClassDeclList (ClassDeclList classDecl classDeclList) classes = 
  if genCodeClassDecl classDecl classes  == "Ok"
  then "Ok"
  else genCodeClassDeclList classDeclList classes 

genCodeClassDecl (ClassDecl className varDeclList methodDeclList) classes =
    if genCodeVarDeclList varDeclList classes [("this", className)] == "Ok" 
    then genCodeMethodDeclList methodDeclList classes [("this", className)]
    else "Fail2"

genCodeVarDeclList VEmpty _ _ = "Ok" -- empty variable declaration list so automatically successful

genCodeVarDeclList (VarDeclList theType ident varDeclList) classes context =
    if checkForDuplicateVarDeclarations (VarDeclList theType ident varDeclList) [] context == "Ok" && genCodeVarDecl theType ident classes context == "Ok" 
    then genCodeVarDeclList varDeclList classes context
    else "Fail3"

getTypeName TypeBool = "bool"
getTypeName TypeInt = "int"
getTypeName TypeString = "string"
getTypeName (TypeIdent ident) = ident
getTypeName (TypeIdentArray ident) = ident


genCodeVarDecl theType ident classes context = 
  case theType of
    TypeBool -> "Ok"
    TypeInt -> "Ok"
    TypeString -> "Ok"
    (TypeIdent typeName) -> case lookup typeName classes of
      Just classSym -> "Ok"
      Nothing -> error ("Unknown type " ++ typeName ++ " in the var declaration list of class " ++ (show (lookup "this" context)))
    (TypeIdentArray typeNameArray) -> let tName = reverse (drop 2 (reverse typeNameArray)) in -- drops the [] at the end of the typeNameArray.
      case lookup tName classes of
        Just classSym -> "Ok"
        Nothing -> error ("Unknown type " ++ typeNameArray ++ " in the var declaration list of class " ++ (show (lookup "this" context)))

genCodeMethodDeclList MEmpty classes context = "Ok" -- no methods so automatically successful
genCodeMethodDeclList (MethodDeclList methodDecl methodDeclList) classes context =
    if checkForDuplicateMethodDeclarations (MethodDeclList methodDecl methodDeclList) [] context == "Ok" && genCodeMethodDecl methodDecl classes context == "Ok" 
    then genCodeMethodDeclList methodDeclList classes context
    else "Fail4"
  

genCodeMethodDecl (MethodDecl theType methodName formalList varDeclList statementList exp) classes context =    
    let context2 = (getThisClassVariables classes context) ++ (getVarDeclListVariables varDeclList classes) ++ (getFormalListVariables formalList classes) ++ context
        typeName = getTypeName theType
    in
      if genCodeStatementList statementList classes context2 == "Ok" 
      then 
        if typeName /=  (genCodeExp exp classes context2)
        then error ("the type of method " ++ methodName ++ " does not match the return type of " ++ (show exp))
        else "Ok"
      else 
        "Fail5"          
                

getThisClassVariables classes context =
    case lookup "this" context of
      Nothing -> error("undeclared this in context: " ++ show context)
      Just thisTypeName -> cVarTypes thisTypeName classes

cVarTypes typeName classes = 
    case lookup typeName classes of
      Nothing -> error("undeclared type: " ++ typeName)
      Just classSym -> publicVariables classSym

getVarDeclListVariables VEmpty _ = [] -- empty variable declaration list

getVarDeclListVariables (VarDeclList theType ident varDeclList) classes = 
    let typeName = getTypeName theType 
    in 
      if lookup typeName classes == Nothing || checkForDuplicateVariableDecls varDeclList [(theType, ident)] /= "Ok"
      then error("unknown type " ++ typeName ++ " for variable " ++ ident)
      else (ident, getTypeName theType) : getVarDeclListVariables varDeclList classes

checkForDuplicateVariableDecls :: VarDeclList -> [(Type, Ident)] -> String
checkForDuplicateVariableDecls VEmpty _ = "Ok"
checkForDuplicateVariableDecls (VarDeclList theType ident varDeclList) varList =
  case elem (theType, ident) varList of
    False -> checkForDuplicateVariableDecls varDeclList ((theType, ident) : varList)
    True -> error("duplicate declaration of " ++ ident ++ " in " ++ show(varDeclList)) 



getFormalListVariables FEmpty classes = []
getFormalListVariables (FormalList theType ident formalList) classes = 
    let typeName = getTypeName theType
    in
      if lookup typeName classes == Nothing || checkForDuplicateFormalListVariables formalList [(theType, ident)] /= "Ok"
      then error("unknown type " ++ typeName ++ " for variable " ++ ident)
      else (ident, getTypeName theType) : getFormalListVariables formalList classes
    
checkForDuplicateFormalListVariables :: FormalList -> [(Type, Ident)] -> String
checkForDuplicateFormalListVariables FEmpty _ = "Ok"
checkForDuplicateFormalListVariables (FormalList theType ident formalList) fList = case elem (theType, ident) fList of
  False -> checkForDuplicateFormalListVariables formalList ([(theType, ident)] ++ fList)
  True -> error("duplicate declaration of " ++ ident ++ " in " ++ show(fList))
      

genCodeMainClass (MClass className paramName statement) classes = if (lookup className classes == Nothing)
                                                                    then error("Error " ++ className ++ " is not a declared class")
                                                                    else genCodeStatement statement classes [("this", className), (paramName, "string[]")]



genCodeStatementList Empty classes context = "Ok"
genCodeStatementList (StatementList statementList statement) classes context =
    if genCodeStatement statement classes context == "Ok" && genCodeStatementList statementList classes context == "Ok"
    then "Ok"
    else "Fail6"

genCodeStatement (SList statementList) classes context = 
    genCodeStatementList statementList classes context
genCodeStatement (SIfElse exp1 statement1 statement2) classes context =
    if (genCodeExp exp1 classes context) == "bool" && genCodeStatement statement1 classes context == "Ok" && genCodeStatement statement2 classes context == "Ok"
    then "Ok"
    else error ("Error in if else statement")

genCodeStatement (SWhile exp statement) classes context = 
      if genCodeExp exp classes context == "bool" 
      then genCodeStatement statement classes context
      else error("Error type of " ++ show(exp) ++ " is not bool in while statement")


genCodeStatement (SEqual ident exp1) classes context = 
    let identType = lookup ident context in
    case identType of 
         Nothing -> error("Error undeclared identifier " ++ ident ++ " in equal statement")
         Just iType -> if iType == genCodeExp exp1 classes context
                     then "Ok"
                     else error("Error types do not match in equals statements, type1 " ++ iType ++ " type2 " ++ (genCodeExp exp1 classes context))


genCodeStatement (SPrint exp) classes context = if genCodeExp exp classes context /= "" then "Ok" else "Fail"
genCodeStatement (SArrayEqual ident exp1 exp2) classes context = 
  case lookup ident context of
    Nothing -> error("Error undeclared identifier " ++ ident ++ " in equal statement")
    Just iType -> if take 2 (reverse iType) /= "[]" then
                    error(ident ++ " is not an array")
                  else 
                    let baseTypeName = reverse (take 2 (reverse iType)) in
                    if baseTypeName /= genCodeExp exp2 classes context || genCodeExp exp1 classes context /= "bool" then
                      error("Error, can't assign to array")
                    else
                      "Ok"

-- some helper functions for genCodeExp

expTypes ExpListEmpty classes context = []
expTypes (ExpList exp expRest) classes context = (genCodeExp exp classes context) : expRestTypes expRest classes context
expTypes (ExpListExp exp) classes context = [genCodeExp exp classes context]
    
expRestTypes (ExpRest exp) classes context = [genCodeExp exp classes context]
        

checkFunctionCall (ClassSymbol cName vars []) methodName [] = 
    error (methodName ++ " is not a method of class " ++ cName)

checkFunctionCall (ClassSymbol cName var methods) methodName methodTypes = 
    let method = lookup methodName methods in
    case method of 
         Just theMethod -> checkMethodTypes theMethod methodTypes
         Nothing -> error (methodName ++ " is not a method of " ++ cName)

checkMethodTypes (MethodSymbol returnType name []) [] = returnType

checkMethodTypes (MethodSymbol returnType name []) methodTypes = error("method " ++ name ++ " doesn't take any arguments but arguments of type " ++ show(methodTypes) ++ " provided")

checkMethodTypes (MethodSymbol returnType name args) [] = error("method " ++ name ++ " takes arguments but no arguments provided")
 
checkMethodTypes (MethodSymbol returnType name ((argName, argType) : args)) (type1 : types)  = 
    if argType == type1 
    then checkMethodTypes (MethodSymbol returnType name args) types 
    else error ("method " ++ name ++ " argument type mismatch " ++ " expected type " ++ argType ++ " but got type " ++ type1)




-- the genCodeExp function returns the type name of the expression
genCodeExp (ExpOp exp1 char exp2) classes context = 
    if genCodeExp exp1 classes context == "int" && genCodeExp exp2 classes context == "int"
       then "int"
       else error ("one of the expressions exp1:" ++ show(exp1) ++ " exp2:" ++ show(exp2) ++ " is not an integer \n exp1 type: " ++ (genCodeExp exp1 classes context) ++ "\n exp2 type: " ++ (genCodeExp exp2 classes context))


genCodeExp (ExpComOp exp1 char exp2) classes context = 
    if genCodeExp exp1 classes context == "int" && genCodeExp exp2 classes context == "int"
       then "bool"
       else error ("one of the expressions exp1:" ++ show(exp1) ++ " exp2:" ++ show(exp2) ++ " is not an integer \n exp1 type: " ++ (genCodeExp exp1 classes context) ++ "\n exp2 type: " ++ (genCodeExp exp2 classes context))


genCodeExp (ExpArray exp1 exp2) classes context  =  -- "Exp [ Exp ]"
  if genCodeExp exp2 classes context /= "int" then
    error("Error in ExpArray")
  else
    if take 2 (reverse (genCodeExp exp1 classes context)) /= "[]" then
      error("Error in ExpArray")
    else
      reverse(drop 2 (reverse (genCodeExp exp1 classes context)))
    
  
genCodeExp (ExpFCall exp ident expList) classes context =   
      let className = genCodeExp exp classes context -- Exp . Ident ( ExpList )
          classSym = lookup className classes
          expListTypes = expTypes expList classes context 
      in case classSym of
           Just x -> (checkFunctionCall x ident expListTypes)
           Nothing -> error ("Undeclared class " ++ className ++ " in function call")

genCodeExp (ExpInt int) classes context = "int"

genCodeExp (ExpNewIntArray exp) classes context = 
    if genCodeExp exp classes context == "int"
       then "int[]"
       else error ("Error new int[exp] the expression type is not an integer")


genCodeExp (ExpNewBoolArray exp) classes context = 
    if genCodeExp exp classes context == "int"
       then "bool[]"
       else error ("Error new bool[exp] the expression type is not an integer")


genCodeExp (ExpNewStringArray exp) classes context = 
    if genCodeExp exp classes context == "int"
       then "string[]"
       else error ("Error new string[exp] the expression type is not an integer")

genCodeExp (ExpBool bool) classes context  = "bool" -- True or False


genCodeExp (ExpIdent ident) classes context = 
    case lookup ident context of
      Just x -> x
      Nothing -> error ("Error " ++ ident ++ " is not a declared variable, context " ++ show context)
                                                       
genCodeExp (ExpNewIdent ident) classes context = 
    if lookup ident classes == Nothing
    then error ("Error " ++ ident ++ " is not a declared class" ++ ", context " ++ show context)
    else ident

genCodeExp (ExpNewIdentArray ident exp) classes context = 
    if lookup ident classes == Nothing || genCodeExp exp classes context /= "int"
    then error ("Error " ++ ident ++ " is not a declared class or " ++ show(exp) ++ " is not an int" ++ ", context " ++ show context)
    else ident ++ "[]"

genCodeExp (ExpExp exp) classes context  = genCodeExp exp classes context -- Exp ( Exp )

genCodeExp (ExpThis) classes context =
    let thisSym = lookup "this" context in
    case thisSym of 
      Just sym -> sym
      Nothing -> error ("this symbol undeclared")

genCodeExp (ExpNot exp) classes context = 
    if genCodeExp exp classes context == "bool"
       then "bool"
       else error "wrong type for !exp, expecting bool type"

genCodeExp (ExpLength exp) classes context =
    if genCodeExp exp classes context == "int[]"
           then "int"
           else error "Error in " ++ show(exp) ++ ".length the expression is not of type int[] "
